import { EventTopicMakeCodeGenerationTargetLanguage } from '@causa/workspace-core';
import { NoImplementationFoundError } from '@causa/workspace/function-registry';
import { createContext, registerMockFunction } from '@causa/workspace/testing';
import {
  type TypeScriptDecorator,
  TypeScriptDecoratorsRenderer,
  TypeScriptWithDecoratorsTargetLanguage,
} from '../../code-generation/index.js';
import { TypeScriptGetDecoratorRenderer } from '../../definitions/index.js';
import { EventTopicMakeCodeGenerationTargetLanguageForTypeScript } from './event-topic-make-code-generation-target-language-ts.js';

class DummyDecoratorRenderer extends TypeScriptDecoratorsRenderer {
  decoratorsForClass(): TypeScriptDecorator[] {
    return [];
  }

  decoratorsForProperty(): TypeScriptDecorator[] {
    return [];
  }
}

class OtherDecoratorRenderer extends TypeScriptDecoratorsRenderer {
  decoratorsForClass(): TypeScriptDecorator[] {
    return [];
  }

  decoratorsForProperty(): TypeScriptDecorator[] {
    return [];
  }
}

describe('EventTopicMakeCodeGenerationTargetLanguageForTypeScript', () => {
  it('should not support a language other than TypeScript', async () => {
    const { context } = createContext({
      projectPath: '/my-project',
      configuration: {
        project: {
          name: 'my-project',
          type: 'serviceContainer',
          language: 'java',
        },
      },
      functions: [EventTopicMakeCodeGenerationTargetLanguageForTypeScript],
    });

    expect(() =>
      context.call(EventTopicMakeCodeGenerationTargetLanguage, {}),
    ).toThrow(NoImplementationFoundError);
  });

  it('should return the TypeScript language', async () => {
    const { context, functionRegistry } = createContext({
      projectPath: '/my-project',
      configuration: {
        project: {
          name: 'my-project',
          type: 'serviceContainer',
          language: 'typescript',
        },
      },
      functions: [EventTopicMakeCodeGenerationTargetLanguageForTypeScript],
    });
    // Registering the mock renderers in reverse order to ensure that they are sorted by name in the result.
    registerMockFunction(
      functionRegistry,
      TypeScriptGetDecoratorRenderer,
      () => OtherDecoratorRenderer,
    );
    registerMockFunction(
      functionRegistry,
      TypeScriptGetDecoratorRenderer,
      () => DummyDecoratorRenderer,
    );

    const actualLanguage = await context.call(
      EventTopicMakeCodeGenerationTargetLanguage,
      {},
    );

    expect(actualLanguage).toBeInstanceOf(
      TypeScriptWithDecoratorsTargetLanguage,
    );
    const actualTypeScriptLanguage =
      actualLanguage as TypeScriptWithDecoratorsTargetLanguage;
    expect(actualTypeScriptLanguage.options).toEqual({
      decoratorRenderers: [DummyDecoratorRenderer, OtherDecoratorRenderer],
      nonNullAssertionOnProperties: true,
      readonlyProperties: true,
      assignConstructor: true,
      leadingComment:
        'This file was generated by the Causa command line. Do not edit it manually.',
      decoratorOptions: {},
    });
    expect(actualTypeScriptLanguage.outputPath).toEqual(
      '/my-project/src/model.ts',
    );
  });

  it('should load options from the configuration', async () => {
    const { context } = createContext({
      projectPath: '/my-project',
      configuration: {
        project: {
          name: 'my-project',
          type: 'serviceContainer',
          language: 'typescript',
        },
        typescript: {
          codeGeneration: {
            outputFile: 'src/generated.ts',
            nonNullAssertionOnProperties: false,
            readonlyProperties: false,
            assignConstructor: false,
            leadingComment: 'ðŸš¨',
            decoratorOptions: { myArg: 'ðŸ”§' },
          },
        },
      },
      functions: [EventTopicMakeCodeGenerationTargetLanguageForTypeScript],
    });

    const actualLanguage = await context.call(
      EventTopicMakeCodeGenerationTargetLanguage,
      {},
    );

    expect(actualLanguage).toBeInstanceOf(
      TypeScriptWithDecoratorsTargetLanguage,
    );
    const actualTypeScriptLanguage =
      actualLanguage as TypeScriptWithDecoratorsTargetLanguage;
    expect(actualTypeScriptLanguage.options).toEqual({
      decoratorRenderers: [],
      nonNullAssertionOnProperties: false,
      readonlyProperties: false,
      assignConstructor: false,
      leadingComment: 'ðŸš¨',
      decoratorOptions: { myArg: 'ðŸ”§' },
    });
    expect(actualTypeScriptLanguage.outputPath).toEqual(
      '/my-project/src/generated.ts',
    );
  });
});
