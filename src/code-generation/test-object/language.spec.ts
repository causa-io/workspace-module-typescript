import { mkdtemp, rm } from 'fs/promises';
import 'jest-extended';
import { tmpdir } from 'os';
import { join } from 'path';
import { pino } from 'pino';
import { expectToMatchRegexParts, generateFromSchema } from '../utils.test.js';
import { TypeScriptTestObjectTargetLanguage } from './language.js';

const SCHEMA = {
  title: 'TestClass',
  type: 'object',
  description: 'ðŸ™ˆ',
  additionalProperties: false,
  properties: {
    stringProp: { type: 'string' },
    uuidProp: { type: 'string', format: 'uuid' },
    integerProp: { type: 'integer' },
    doubleProp: { type: 'number' },
    boolProp: { type: 'boolean' },
    dateProp: { type: 'string', format: 'date' },
    dateTimeProp: { type: 'string', format: 'date-time' },
    arrayProp: { type: 'array', items: { type: 'string' } },
    mapProp: { type: 'object', additionalProperties: { type: 'string' } },
    enumProp: { oneOf: [{ $ref: '#/$defs/MyEnum' }] },
    classProp: { oneOf: [{ $ref: '#/$defs/ChildClass' }] },
    constProp: { const: 'ðŸª¨' },
    nullableString: { oneOf: [{ type: 'string' }, { type: 'null' }] },
    nullableClass: {
      oneOf: [{ $ref: '#/$defs/ChildClass' }, { type: 'null' }],
    },
    optionalString: { type: 'string' },
    optionalInteger: { type: 'integer' },
  },
  required: ['stringProp', 'integerProp', 'boolProp', 'arrayProp', 'classProp'],
  $defs: {
    MyEnum: { type: 'string', enum: ['FIRST', 'SECOND', 'THIRD'] },
    ChildClass: {
      title: 'ChildClass',
      type: 'object',
      additionalProperties: false,
      properties: {
        childString: { type: 'string' },
        childNumber: { type: 'integer' },
      },
      required: ['childString'],
    },
  },
};

describe('TypeScriptTestObjectRenderer', () => {
  let tmpDir: string;
  let outputFile: string;

  beforeEach(async () => {
    tmpDir = await mkdtemp(join(tmpdir(), 'causa-test-'));
    outputFile = join(tmpDir, 'test-output.ts');
  });

  afterEach(async () => {
    await rm(tmpDir, { recursive: true, force: true });
  });

  it('should generate make functions with fallback imports when modelClassSchemas is not provided', async () => {
    const modelClassOutputFile = join(tmpDir, 'model.ts');
    const modelClassSchemas = {
      'test.json': { name: 'TestClass', file: modelClassOutputFile },
      'test.json#/$defs/ChildClass': {
        name: 'OtherName',
        file: modelClassOutputFile,
      },
      'test.json#/$defs/MyEnum': {
        name: 'MySpecialEnum',
        file: modelClassOutputFile,
      },
    };
    const language = new TypeScriptTestObjectTargetLanguage(
      outputFile,
      pino(),
      { leadingComment: 'Test objects generated by test', modelClassSchemas },
    );

    const actualCode = await generateFromSchema(language, SCHEMA, outputFile);

    expect(actualCode).toStartWith('// Test objects generated by test');
    expectToMatchRegexParts(actualCode, [
      'import \\{ randomUUID \\} from "crypto";',
      'import \\{ MySpecialEnum, OtherName, TestClass \\} from "\\./model\\.js";',
    ]);
    expectToMatchRegexParts(actualCode, [
      'export function makeTestClass\\(data: Partial<TestClass> = {}\\): TestClass \\{',
      'return new TestClass\\({',
      'arrayProp: \\[\\],',
      'boolProp: false,',
      'classProp: makeChildClass\\(\\),',
      'constProp: "ðŸª¨",',
      'dateProp: new Date\\(\\),',
      'dateTimeProp: new Date\\(\\),',
      'doubleProp: 0\\.0,',
      'enumProp: MySpecialEnum.First,',
      'integerProp: 0,',
      'mapProp: {},',
      'nullableClass: null,',
      'nullableString: null,',
      'optionalInteger: 0,',
      'optionalString: "string",',
      'stringProp: "string",',
      'uuidProp: randomUUID\\(\\),',
      '...data,',
      '}\\);',
    ]);
    expectToMatchRegexParts(actualCode, [
      'export function makeChildClass\\(data: Partial<OtherName> = {}\\): OtherName \\{',
      'return new OtherName\\({',
      'childNumber: 0,',
      'childString: "string",',
      '...data,',
      '\\}\\);',
      '\\}',
    ]);
    expect(actualCode).not.toContain('enum MyEnum');
    expect(actualCode).not.toContain('ðŸ™ˆ');
    expect(language.generatedSchemas).toEqual({
      'test.json': { name: 'makeTestClass', file: outputFile },
      'test.json#/$defs/ChildClass': {
        name: 'makeChildClass',
        file: outputFile,
      },
    });
  });

  it('should handle constraintFor attribute correctly', async () => {
    const schemaWithConstraint = {
      title: 'Person',
      type: 'object',
      additionalProperties: false,
      properties: {
        name: { type: 'string' },
        age: { oneOf: [{ type: 'integer' }, { type: 'null' }] },
        dummyRefToConstraint: {
          oneOf: [{ $ref: '#/$defs/PersonWithAgeConstraint' }],
        },
      },
      required: ['name', 'age'],
      $defs: {
        PersonWithAgeConstraint: {
          title: 'PersonWithAgeConstraint',
          type: 'object',
          additionalProperties: false,
          causa: { constraintFor: '#' },
          properties: { age: { type: 'integer' } },
          required: ['age'],
        },
      },
    };
    const modelClassOutputFile = join(tmpDir, 'model.ts');
    const modelClassSchemas = {
      'test.json': { name: 'Person', file: modelClassOutputFile },
      'test.json#/$defs/PersonWithAgeConstraint': {
        name: 'PersonWithAge',
        file: modelClassOutputFile,
      },
    };

    const language = new TypeScriptTestObjectTargetLanguage(
      outputFile,
      pino(),
      { modelClassSchemas },
    );
    const actualCode = await generateFromSchema(
      language,
      schemaWithConstraint,
      outputFile,
    );

    expect(actualCode).not.toContain('crypto');
    expectToMatchRegexParts(actualCode, [
      'import \\{ Person, type PersonWithAge \\} from "\\./model\\.js";',
    ]);
    expectToMatchRegexParts(actualCode, [
      'export function makePersonWithAge\\(',
      'data: Partial<PersonWithAge> = \\{\\},',
      '\\): PersonWithAge \\{',
      'return new Person\\(\\{',
      'age: 0,',
      'name: "string",',
      '...data,',
      '\\}\\) as PersonWithAge;',
      'export function makePerson\\(data: Partial<Person> = \\{\\}\\): Person \\{',
      'return new Person\\(\\{',
      'age: null,',
      'name: "string",',
      '...data,',
      '\\}\\);',
    ]);
    expect(language.generatedSchemas).toEqual({
      'test.json': { name: 'makePerson', file: outputFile },
      'test.json#/$defs/PersonWithAgeConstraint': {
        name: 'makePersonWithAge',
        file: outputFile,
      },
    });
  });
});
